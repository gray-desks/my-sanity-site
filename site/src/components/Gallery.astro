---
interface ImageAsset {
  asset: {
    _ref: string
    url?: string
  }
}

interface Props {
  images: ImageAsset[]
}

const { images } = Astro.props
const galleryId = `gallery-${Math.random().toString(36).substr(2, 9)}`

// Prepare optimized image URLs for JavaScript
const imageUrls = images.map(img => `${img.asset?.url}?auto=format&w=800&q=85`)
---

<div class="gallery-container" data-gallery-id={galleryId} data-image-urls={JSON.stringify(imageUrls)}>
  <div class="relative">
    <!-- Main image display -->
    <div class="gallery-main aspect-video bg-gray-100 rounded-lg overflow-hidden">
      <img 
        id={`${galleryId}-main`}
        src={`${images[0]?.asset?.url}?auto=format&w=800&q=85`}
        alt=""
        class="w-full h-full object-contain transition-opacity duration-300 cursor-pointer bg-gray-50"
        loading="lazy"
        decoding="async"
        data-gallery-lightbox={galleryId}
      />
    </div>

    <!-- Navigation arrows -->
    {images.length > 1 && (
      <div class="absolute inset-y-0 left-0 flex items-center">
        <button 
          class="gallery-prev bg-black bg-opacity-50 text-white p-2 rounded-r-md hover:bg-opacity-75 transition-all"
          data-gallery={galleryId}
        >
          ←
        </button>
      </div>
    )}
    
    {images.length > 1 && (
      <div class="absolute inset-y-0 right-0 flex items-center">
        <button 
          class="gallery-next bg-black bg-opacity-50 text-white p-2 rounded-l-md hover:bg-opacity-75 transition-all"
          data-gallery={galleryId}
        >
          →
        </button>
      </div>
    )}

    <!-- Image counter -->
    {images.length > 1 && (
      <div class="absolute bottom-4 right-4 bg-black bg-opacity-50 text-white px-3 py-1 rounded-full text-sm">
        <span id={`${galleryId}-counter`}>1</span> / {images.length}
      </div>
    )}
  </div>

  <!-- Thumbnail strip -->
  {images.length > 1 && (
    <div class="mt-4 flex gap-2 overflow-x-auto pb-2">
      {images.map((image, index) => (
        <button
          class={`gallery-thumb flex-shrink-0 w-20 h-20 rounded-md overflow-hidden border-2 transition-all ${
            index === 0 ? 'border-blue-500' : 'border-transparent hover:border-gray-300'
          }`}
          data-gallery={galleryId}
          data-index={index}
        >
          <img 
            src={`${image.asset?.url}?w=80&h=80&fit=crop&auto=format`}
            alt=""
            class="w-full h-full object-cover"
            loading="lazy"
            decoding="async"
          />
        </button>
      ))}
    </div>
  )}
  
  <!-- Lightbox Modal -->
  <div id={`${galleryId}-lightbox`} class="lightbox-overlay hidden fixed inset-0 bg-black bg-opacity-90 z-50 flex items-center justify-center p-4">
    <div class="relative max-w-7xl max-h-full flex items-center justify-center">
      <!-- Close button -->
      <button class="lightbox-close absolute top-4 right-4 text-white text-2xl hover:text-gray-300 transition-colors z-10 bg-black bg-opacity-50 rounded-full w-10 h-10 flex items-center justify-center">
        ×
      </button>
      
      <!-- Lightbox navigation arrows -->
      {images.length > 1 && (
        <>
          <button class="lightbox-prev absolute left-4 top-1/2 -translate-y-1/2 bg-black bg-opacity-50 text-white p-3 rounded-full hover:bg-opacity-75 transition-all text-xl">
            ←
          </button>
          <button class="lightbox-next absolute right-4 top-1/2 -translate-y-1/2 bg-black bg-opacity-50 text-white p-3 rounded-full hover:bg-opacity-75 transition-all text-xl">
            →
          </button>
        </>
      )}
      
      <!-- Lightbox main image (fixed frame) -->
      <div class="lightbox-frame">
        <img 
          id={`${galleryId}-lightbox-image`}
          src={`${images[0]?.asset?.url}?auto=format`}
          alt=""
          class="w-full h-full object-contain cursor-pointer"
        />
      </div>
      
      <!-- Image counter in lightbox -->
      {images.length > 1 && (
        <div class="absolute bottom-4 left-1/2 -translate-x-1/2 bg-black bg-opacity-50 text-white px-4 py-2 rounded-full text-sm">
          <span id={`${galleryId}-lightbox-counter`}>1</span> / {images.length}
        </div>
      )}
    </div>
  </div>
</div>

<script>
  class Gallery {
    constructor(container) {
      this.container = container
      this.galleryId = container.dataset.galleryId
      this.images = this.getImageUrls()
      this.currentIndex = 0
      this._transitionTimer = null
      this._preloadedImages = new Map() // Cache for preloaded images
      
      this.mainImage = document.getElementById(`${this.galleryId}-main`)
      this.counter = document.getElementById(`${this.galleryId}-counter`)
      this.thumbs = container.querySelectorAll('.gallery-thumb')
      
      // Lightbox elements
      this.lightbox = document.getElementById(`${this.galleryId}-lightbox`)
      this.lightboxImage = document.getElementById(`${this.galleryId}-lightbox-image`)
      this.lightboxCounter = document.getElementById(`${this.galleryId}-lightbox-counter`)
      this.isLightboxOpen = false
      
      this.bindEvents()
      this.setupIntersectionObserver()
      this.preloadAllImages() // Preload all images for faster switching
    }
    
    getImageUrls() {
      // Get image URLs from data attribute set by Astro
      const imageUrls = this.container.dataset.imageUrls
      return imageUrls ? JSON.parse(imageUrls) : []
    }
    
    preloadAllImages() {
      // Preload all images for faster switching
      this.images.forEach((url, index) => {
        if (!this._preloadedImages.has(url)) {
          const img = new Image()
          img.decoding = 'async'
          img.onload = () => {
            this._preloadedImages.set(url, img)
          }
          img.onerror = () => {
            console.warn(`Failed to preload image: ${url}`)
          }
          img.src = url
        }
      })
    }
    
    bindEvents() {
      // Navigation buttons
      const prevBtn = this.container.querySelector('.gallery-prev')
      const nextBtn = this.container.querySelector('.gallery-next')
      
      prevBtn?.addEventListener('click', () => this.prev())
      nextBtn?.addEventListener('click', () => this.next())
      
      // Thumbnail clicks
      this.thumbs.forEach((thumb, index) => {
        thumb.addEventListener('click', () => this.goTo(index))
      })
      
      // Main image click for lightbox
      this.mainImage?.addEventListener('click', () => this.openLightbox())
      
      // Lightbox events
      if (this.lightbox) {
        // Close lightbox
        this.lightbox.querySelector('.lightbox-close')?.addEventListener('click', () => this.closeLightbox())
        this.lightboxImage?.addEventListener('click', () => this.closeLightbox())
        this.lightbox.addEventListener('click', (e) => {
          if (e.target === this.lightbox) this.closeLightbox()
        })
        
        // Lightbox navigation
        this.lightbox.querySelector('.lightbox-prev')?.addEventListener('click', () => this.prevLightbox())
        this.lightbox.querySelector('.lightbox-next')?.addEventListener('click', () => this.nextLightbox())
      }
      
      // Keyboard navigation
      document.addEventListener('keydown', (e) => {
        if (this.isLightboxOpen) {
          if (e.key === 'Escape') this.closeLightbox()
          if (e.key === 'ArrowLeft') this.prevLightbox()
          if (e.key === 'ArrowRight') this.nextLightbox()
        } else if (this.isVisible()) {
          if (e.key === 'ArrowLeft') this.prev()
          if (e.key === 'ArrowRight') this.next()
        }
      })
    }
    
    setupIntersectionObserver() {
      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              this.loadImagesLazily()
            }
          })
        },
        { rootMargin: '50px' }
      )
      
      observer.observe(this.container)
    }
    
    loadImagesLazily() {
      const images = this.container.querySelectorAll('img[loading="lazy"]')
      images.forEach(img => {
        if (img.dataset.src) {
          img.src = img.dataset.src
          img.removeAttribute('data-src')
          img.removeAttribute('loading')
        }
      })
    }
    
    prev() {
      if (!this.images?.length) return
      this.currentIndex = this.currentIndex > 0 ? this.currentIndex - 1 : this.images.length - 1
      this.updateDisplay()
    }
    
    next() {
      if (!this.images?.length) return
      this.currentIndex = this.currentIndex < this.images.length - 1 ? this.currentIndex + 1 : 0
      this.updateDisplay()
    }
    
    goTo(index) {
      if (!this.images?.length) return
      const safeIndex = Math.max(0, Math.min(index, this.images.length - 1))
      this.currentIndex = safeIndex
      this.updateDisplay()
    }
    
    updateDisplay() {
      if (!this.mainImage || !this.images?.length) return
      // Clear any pending transition to avoid race conditions on rapid clicks
      if (this._transitionTimer) {
        clearTimeout(this._transitionTimer)
        this._transitionTimer = null
      }
      
      const nextUrl = this.images[this.currentIndex]
      
      // Check if image is already preloaded
      if (this._preloadedImages.has(nextUrl)) {
        // Image is already loaded, switch immediately
        this.mainImage.style.opacity = '0'
        this._transitionTimer = setTimeout(() => {
          this.mainImage.src = nextUrl
          this.mainImage.style.opacity = '1'
          this._transitionTimer = null
        }, 50) // Reduced fade time for preloaded images
      } else {
        // Fallback: load on demand (should rarely happen with preloading)
        this.mainImage.style.opacity = '0'
        const img = new Image()
        img.onload = () => {
          this._preloadedImages.set(nextUrl, img)
          this._transitionTimer = setTimeout(() => {
            this.mainImage.src = nextUrl
            this.mainImage.style.opacity = '1'
            this._transitionTimer = null
          }, 100)
        }
        img.onerror = () => {
          this.mainImage.src = nextUrl
          this.mainImage.style.opacity = '1'
        }
        img.decoding = 'async'
        img.src = nextUrl
      }
      
      // Update counter
      if (this.counter) {
        this.counter.textContent = this.currentIndex + 1
      }
      
      // Update thumbnail borders
      this.thumbs.forEach((thumb, index) => {
        if (index === this.currentIndex) {
          thumb.classList.remove('border-transparent')
          thumb.classList.add('border-blue-500')
        } else {
          thumb.classList.remove('border-blue-500')
          thumb.classList.add('border-transparent')
        }
      })
    }
    
    isVisible() {
      const rect = this.container.getBoundingClientRect()
      return rect.top < window.innerHeight && rect.bottom > 0
    }
    
    // Lightbox methods
    openLightbox() {
      this.isLightboxOpen = true
      this.lightbox.classList.remove('hidden')
      this.updateLightboxDisplay()
      document.body.style.overflow = 'hidden'
    }
    
    closeLightbox() {
      this.isLightboxOpen = false
      this.lightbox.classList.add('hidden')
      document.body.style.overflow = ''
    }
    
    prevLightbox() {
      if (!this.images?.length) return
      this.currentIndex = this.currentIndex > 0 ? this.currentIndex - 1 : this.images.length - 1
      this.updateLightboxDisplay()
      this.updateDisplay()
    }
    
    nextLightbox() {
      if (!this.images?.length) return
      this.currentIndex = this.currentIndex < this.images.length - 1 ? this.currentIndex + 1 : 0
      this.updateLightboxDisplay()
      this.updateDisplay()
    }
    
    updateLightboxDisplay() {
      if (this.lightboxImage) {
        this.lightboxImage.src = this.images[this.currentIndex]
      }
      
      if (this.lightboxCounter) {
        this.lightboxCounter.textContent = this.currentIndex + 1
      }
    }
  }
  
  // Initialize all galleries on the page
  document.addEventListener('DOMContentLoaded', () => {
    const galleries = document.querySelectorAll('.gallery-container')
    galleries.forEach(container => new Gallery(container))
  })
</script>

<style>
  .gallery-container {
    max-width: 100%;
  }
  
  .gallery-main img {
    transition: opacity 0.15s ease-out;
    object-fit: contain;
    background-color: #f8fafc;
  }
  
  .gallery-thumb {
    cursor: pointer;
    transition: border-color 0.2s ease;
  }
  
  .gallery-thumb:hover {
    border-color: #cbd5e0;
  }
  
  .gallery-prev,
  .gallery-next {
    opacity: 0.8;
    transition: opacity 0.2s ease;
  }
  
  .gallery-prev:hover,
  .gallery-next:hover {
    opacity: 1;
  }
  
  /* Custom scrollbar for thumbnails */
  .gallery-container .overflow-x-auto::-webkit-scrollbar {
    height: 4px;
  }
  
  .gallery-container .overflow-x-auto::-webkit-scrollbar-track {
    background: #f1f5f9;
  }
  
  .gallery-container .overflow-x-auto::-webkit-scrollbar-thumb {
    background: #cbd5e0;
    border-radius: 4px;
  }
  
  .gallery-container .overflow-x-auto::-webkit-scrollbar-thumb:hover {
    background: #94a3b8;
  }
  
  /* Lightbox styles */
  .lightbox-overlay {
    backdrop-filter: blur(4px);
    animation: fadeIn 0.2s ease-out;
  }
  
  .lightbox-overlay.hidden {
    display: none !important;
  }
  
  @keyframes fadeIn {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }
  
  .lightbox-overlay img {
    object-fit: contain;
    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
  }
  
  .lightbox-overlay button {
    user-select: none;
    outline: none;
  }
  
  .lightbox-overlay button:focus {
    outline: 2px solid white;
    outline-offset: 2px;
  }

  /* Fixed-size frame for lightbox to avoid layout jumping by source size */
  .lightbox-frame {
    width: min(90vw, 1200px);
    height: min(80vh, 800px);
    display: flex;
    align-items: center;
    justify-content: center;
  }
</style>